#ifndef UGDK_GRAPHIC_VIDEOMANAGER_H_
#define UGDK_GRAPHIC_VIDEOMANAGER_H_

#include <string>
#include <list>
#include <bitset>
#include <ugdk/structures/types.h>
#include <ugdk/math/vector2D.h>
#include <ugdk/math/integer2D.h>
#include <ugdk/math/frame.h>
#include <ugdk/action.h>
#include <ugdk/graphic.h>
#include <ugdk/graphic/geometry.h>

namespace ugdk {
namespace graphic {

struct VideoSettings {
    std::string window_title;
    std::string window_icon;
    math::Integer2D resolution;
    bool fullscreen;
    bool vsync;
    bool light_system;

    VideoSettings();
    VideoSettings(const std::string& title,
                  const std::string& icon,
                  const math::Integer2D& _resolution, 
                  bool _fullscreen,
                  bool _vsync,
                  bool _light_system) 
        : 
        window_title(title),
        window_icon(icon),
        resolution(_resolution),
        fullscreen(_fullscreen), vsync(_vsync), light_system(_light_system) {}
};

action::Scene* CreateLightrenderingScene(std::function<void (const graphic::Geometry&, const graphic::VisualEffect&)> render_light_function);

class Manager {
  public:
    static const int COLOR_DEPTH = 32;

    Manager(const VideoSettings& settings);
    ~Manager() {}

    bool Initialize();
    void Release();

    void Render(const std::list<action::Scene*>&);

    /// Updates the settings and applies the changes.
    /** Warning: changing the resolution and/or fullscreen is a slow operation. */
    bool ChangeSettings(const VideoSettings& new_settings);

    void SaveBackbufferToTexture(Texture* texture);
    
    /// Convenience
    const math::Integer2D& video_size() const { return settings_.resolution; }

    // Getters
    const VideoSettings& settings() const { return settings_; }
    Texture* white_texture() { return white_texture_; }
    Texture* light_buffer() { return light_buffer_; }
    opengl::ShaderProgram* light_shader() { return light_shader_; }

    class Shaders {
      public:
        enum Flag {
            USE_LIGHT_BUFFER = 0,
            IGNORE_TEXTURE_COLOR,

            NUM_FLAGS // Value generated by the compiler
        };

        const opengl::ShaderProgram* current_shader() const;
        
        const opengl::ShaderProgram* GetSpecificShader(const std::bitset<NUM_FLAGS>& flags) const;

        void ChangeFlag(Flag, bool);

        /// Replace the ShaderProgram UGDK uses for the given combination of flags.
        /** @arg flags A STL bitset containing the flags.
            @arg program The ShaderProgram to use. This assumes you're passing the ownership of the object.
        */
        void ReplaceShader(const std::bitset<NUM_FLAGS>& flags, opengl::ShaderProgram* program);
        
        void ReplaceShader(unsigned long flags, opengl::ShaderProgram* program) {
            ReplaceShader(std::bitset<NUM_FLAGS>(flags), program);
        }

        void ReplaceShader(const std::string& flags, opengl::ShaderProgram* program) {
            ReplaceShader(std::bitset<NUM_FLAGS>(flags), program);
        }

      private:
        Shaders();
        ~Shaders();

        opengl::ShaderProgram* shaders_[1 << NUM_FLAGS];
        std::bitset<NUM_FLAGS> flags_;

        friend class Manager;
    };

    Shaders& shaders() { return shaders_; }
    const Shaders& shaders() const { return shaders_; }

  private:
    bool UpdateResolution();
    void UpdateVSync();
    void initializeLight();
    void mergeLights(const std::list<action::Scene*>& scene_list);

    VideoSettings settings_;

    Texture* light_buffer_;
    Texture* white_texture_;
    Geometry initial_geometry_;
    
    Shaders shaders_;
    opengl::ShaderProgram* light_shader_;
};

}  // namespace graphic
}  // namespace ugdk

#endif
