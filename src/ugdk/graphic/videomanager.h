#ifndef UGDK_GRAPHIC_VIDEOMANAGER_H_
#define UGDK_GRAPHIC_VIDEOMANAGER_H_

#include <string>
#include <list>
#include <bitset>
#include <ugdk/base/types.h>
#include <ugdk/math/vector2D.h>
#include <ugdk/math/frame.h>
#include <ugdk/action.h>
#include <ugdk/graphic.h>
#include <ugdk/graphic/geometry.h>

#define VIDEO_MANAGER() (ugdk::Engine::reference()->video_manager())

namespace ugdk {
namespace graphic {

class VideoManager {
  public:
    static const int COLOR_DEPTH = 32;

    VideoManager() : settings_(false, false, false), light_buffer_(nullptr), white_texture_(nullptr), light_shader_(nullptr) {}
    ~VideoManager() {}

    bool Initialize(const std::string& title, const ugdk::math::Vector2D& size, bool fullscreen, const std::string& icon);
    bool Release();
    void Render(const std::list<action::Scene*>&);

    // Configuration
    bool ChangeResolution(const ugdk::math::Vector2D& size, bool fullscreen);
    void SetVSync(const bool active);
    void SetLightSystem(const bool active) { settings_.light_system = active; }

    // Getters
    ugdk::math::Vector2D video_size() const { return video_size_; }
    bool fullscreen() const { return settings_.fullscreen; }
    const std::string& title() const { return title_; }
    Texture* white_texture() { return white_texture_; }
    Texture* light_buffer() { return light_buffer_; }
    opengl::ShaderProgram* light_shader() { return light_shader_; }

    class Shaders {
      public:
        enum Flag {
            USE_LIGHT_BUFFER = 0,
            IGNORE_TEXTURE_COLOR,

            NUM_FLAGS // Value generated by the compiler
        };

        const opengl::ShaderProgram* current_shader() const;

        void ChangeFlag(Flag, bool);

        /// Replace the ShaderProgram UGDK uses for the given combination of flags.
        /** @arg flags A STL bitset containing the flags.
            @arg program The ShaderProgram to use. This assumes you're passing the ownership of the object.
        */
        void ReplaceShader(const std::bitset<NUM_FLAGS>& flags, opengl::ShaderProgram* program);
        
        void ReplaceShader(unsigned long flags, opengl::ShaderProgram* program) {
            ReplaceShader(std::bitset<NUM_FLAGS>(flags), program);
        }

        void ReplaceShader(const std::string& flags, opengl::ShaderProgram* program) {
            ReplaceShader(std::bitset<NUM_FLAGS>(flags), program);
        }

      private:
        Shaders();
        ~Shaders();

        opengl::ShaderProgram* shaders_[1 << NUM_FLAGS];
        std::bitset<NUM_FLAGS> flags_;

        friend class VideoManager;
    };

    Shaders& shaders() { return shaders_; }
    const Shaders& shaders() const { return shaders_; }

  private:
    ugdk::math::Vector2D video_size_;
    std::string title_;

    struct Settings {
        bool fullscreen;
        bool vsync;
        bool light_system;

        Settings(bool fs, bool vs, bool light) : fullscreen(fs), vsync(vs), light_system(light) {}
    } settings_;

    Texture* light_buffer_;
    Texture* white_texture_;
    Geometry initial_geometry_;
    
    Shaders shaders_;
    opengl::ShaderProgram* light_shader_;

    void initializeLight();
    void mergeLights(const std::list<action::Scene*>& scene_list);
};

}  // namespace graphic
}  // namespace ugdk

#endif
