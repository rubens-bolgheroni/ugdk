/***************************************************************************
     Ei Wil (ou sabe-se la' que fantasma do repositorio ta' lendo isso) 

	Criei esse arquivo para irmos adicionando notas/TODOs gerais sobre o 
	sistema (e as implementacoes das linguagens) e sobre o SWIG
	para nao esquecermos =P
***************************************************************************/

###############
Reuniao QuartaFeira dia 1/02:
    discutir interface do sistema para registrar modulos e suas funcoes de init
    que o SWIG gera, assim podemos nukar os .SO =D
    [Wil] preciso lembrar de te explicar porquê fiz o método Copy no VData. Tem
          a ver com possibilitar o "set" de atributos.
################
Em Python (checar Python/C API, Utilities, Importing Modules):
    Aparentemente tem um jeito, pela API, pra setar modulos de python em
    runtime, pelo codigo.
    Isso pode ser util para nao ter que existir a lib separada (o .so) para
    python importar (pelo que lembro, Lua tb nao precisa) pq ai podemos criar
    um modulo novo pelo nosso proprio codigo, soh precisamos da funcao de
    inicializacao que o SWIG gera.
    
    Problema eh, essa inicializacao do modulo precisa ser feita antes do
    Py_Initialize (inicializacao do interpretador do python)... Entao ai sei la
    como resolveriamos isso... Curioso é que a Boost.Python com aquelas macros
    malucas precisava que vc chamasse a funcao initModulo antes do Py_Initialize
    tambem, acho que agora sei porque ahahahahaha
################
Ver com o Wil sobre o método dele pra transformar args VData recebidos numa
implementacao de VData em seu objeto (PyVData)
################
Python, traduzindo GetAttr/GetItem da API para o GetAttr da nossa interface:
    tenta coisas como tipo, checar se objeto eh um dict, se sim usa GetItem,
    senao usa GetAttr.
################
Omar! Parte I das coisas que fiz na interface. Tema de hoje, "Os Wrappers da
Vida".

Como havia dito na reunião, concentrei toda a implementação de função de wrap
na classe VirtualData. Existem cinco versões diferentes, que acho que são
suficientes para a grande maioria dos usos que faremos do sistema de script.

Mas eu mudei o WrapData do LangWrapper. Na verdade, eu semi-nukei ele. Na
verdade da verdade, eu movi ele para o VirtualObject sob o nome de "Create".
Tem umas quatro versões dele, se você ver lá acho que vc vai entender. No
LangWrapper criei um novo método abstrato "NewData" que deve devolver um novo
VData::Ptr criado com o construtor padrão da classe filha. Você precisa
implementar ele!

Se quiser depois podemos discutir essas escolhas, mas eu acho que estou
conseguindo simplificar as coiasas...

Resumindo: implemente os métodos Wrap do VData e o NewData do seu Wrapper.

################
Possível otimização, falar com Omar -> lazyness na hora de ler um atributo.

################

################
RANT MODE ON
	O Wil, pq mudar o VO op() pra usar iterator? 
	Vector é mais eficiente para acesso direto a uma posicao (v[i] - constante)
	e a iterar em QUALQUER ordem ( O(n) ), enquanto
	List só é mais eficiente pra iterar de forma linear do começo ao fim ou
	vice-versa (dai se usa iterator) =P
	Iterators are ugly, stop putting them everywhere =P  lol
RANT MODE OFF
ANSWER
    Eu usei iterators de vector, que funcionam exatamente como índices. Cada
    contêiner da STL (vector, list, map) tem uma implementação diferente de
    iterator, cada um adequado à situação para ter a melhor eficiência. No caso
    do op(), ele tava com um errinho de compilação (eu testei aqui) e já que ia
    precisar mexer nele, mudei pra iterators que é um padrão mais aceito em C++.
    Se te incomodar MTO eu mudo pra índices de volta, mas é sério, pra vector os
    dois jeitos dão exatamente na mesma =P.
    extra: os iterators foram projetados para "funcionarem" como ponteiros, e
           todo contêiner STL tem EXATAMENTE a mesma interface de iterator,
           apesar da implementação ser diferente. Isso significa que um código
           que usa iterators pode ser reaproveitado para qualquer tipo de
           contêiner STL.
REPLY
	lol eu sei que não tem diferenca =P
	Eh que não sei porque, me perturba ver codigo com iterator xD
	Eh como se fosse um foreach mas escrito com muito mais coisa e mais feio ai
	fico "Y U NO FOREACH?!?"
	xD
#################
