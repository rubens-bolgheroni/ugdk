/***************************************************************************
     Ei Wil (ou sabe-se la' que fantasma do repositorio ta' lendo isso) 

	Criei esse arquivo para irmos adicionando notas/TODOs gerais sobre o 
	sistema (e as implementacoes das linguagens) e sobre o SWIG
	para nao esquecermos =P
***************************************************************************/

###############
Reuniao QuartaFeira dia 1/02:
    discutir interface do sistema para registrar modulos e suas funcoes de init
    que o SWIG gera, assim podemos nukar os .SO =D
    [Wil] preciso lembrar de te explicar porquê fiz o método Copy no VData. Tem
          a ver com possibilitar o "set" de atributos.
################
Em Python (checar Python/C API, Utilities, Importing Modules):
    Aparentemente tem um jeito, pela API, pra setar modulos de python em
    runtime, pelo codigo.
    Isso pode ser util para nao ter que existir a lib separada (o .so) para
    python importar (pelo que lembro, Lua tb nao precisa) pq ai podemos criar
    um modulo novo pelo nosso proprio codigo, soh precisamos da funcao de
    inicializacao que o SWIG gera.
    
    Problema eh, essa inicializacao do modulo precisa ser feita antes do
    Py_Initialize (inicializacao do interpretador do python)... Entao ai sei la
    como resolveriamos isso... Curioso é que a Boost.Python com aquelas macros
    malucas precisava que vc chamasse a funcao initModulo antes do Py_Initialize
    tambem, acho que agora sei porque ahahahahaha
################
Ver com o Wil sobre o método dele pra transformar args VData recebidos numa
implementacao de VData em seu objeto (PyVData)
################
Python, traduzindo GetAttr/GetItem da API para o GetAttr da nossa interface:
    tenta coisas como tipo, checar se objeto eh um dict, se sim usa GetItem,
    senao usa GetAttr.
################


################
RANT MODE ON
	O Wil, pq mudar o VO op() pra usar iterator? 
	Vector é mais eficiente para acesso direto a uma posicao (v[i] - constante)
	e a iterar em QUALQUER ordem ( O(n) ), enquanto
	List só é mais eficiente pra iterar de forma linear do começo ao fim ou
	vice-versa (dai se usa iterator) =P
	Iterators are ugly, stop putting them everywhere =P  lol
RANT MODE OFF
ANSWER
    Eu usei iterators de vector, que funcionam exatamente como índices. Cada
    contêiner da STL (vector, list, map) tem uma implementação diferente de
    iterator, cada um adequado à situação para ter a melhor eficiência. No caso
    do op(), ele tava com um errinho de compilação (eu testei aqui) e já que ia
    precisar mexer nele, mudei pra iterators que é um padrão mais aceito em C++.
    Se te incomodar MTO eu mudo pra índices de volta, mas é sério, pra vector os
    dois jeitos dão exatamente na mesma =P.
    extra: os iterators foram projetados para "funcionarem" como ponteiros, e
           todo contêiner STL tem EXATAMENTE a mesma interface de iterator,
           apesar da implementação ser diferente. Isso significa que um código
           que usa iterators pode ser reaproveitado para qualquer tipo de
           contêiner STL.
REPLY
	lol eu sei que não tem diferenca =P
	Eh que não sei porque, me perturba ver codigo com iterator xD
	Eh como se fosse um foreach mas escrito com muito mais coisa e mais feio ai
	fico "Y U NO FOREACH?!?"
	xD
#################
