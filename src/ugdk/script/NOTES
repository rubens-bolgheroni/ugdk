/***************************************************************************
     Ei Wil (ou sabe-se la' que fantasma do repositorio ta' lendo isso) 

	Criei esse arquivo para irmos adicionando notas/TODOs gerais sobre o 
	sistema (e as implementacoes das linguagens) e sobre o SWIG
	para nao esquecermos =P
***************************************************************************/

###############
Omar, mudei a assinatura da função Execute para ela não ficar copiando de boba
o vetor de argumentos. Então tive que ajustar a assinatura dela no PyData tb.

###############
BugFix:
funcao LoadModule dos ScriptManager e LangWrappers esperam um caminho absoluto,
para um arquivo real. Porem a implementacao python espera o caminho na notacao
de import do python:  pacote.subpacote.modulo

###############
Novas ideias para a interface:
	-Feature: funcao que recebe um string 'comando' e executa ele como
		codigo de uma linguagem (no Wrapper)

###############
Reuniao QuartaFeira dia 1/02:
    discutir interface do sistema para registrar modulos e suas funcoes de init
    que o SWIG gera, assim podemos nukar os .SO =D
    [Wil] preciso lembrar de te explicar porquê fiz o método Copy no VData. Tem
          a ver com possibilitar o "set" de atributos.
################
Em Python (checar Python/C API, Utilities, Importing Modules):
    Aparentemente tem um jeito, pela API, pra setar modulos de python em
    runtime, pelo codigo.
    Isso pode ser util para nao ter que existir a lib separada (o .so) para
    python importar (pelo que lembro, Lua tb nao precisa) pq ai podemos criar
    um modulo novo pelo nosso proprio codigo, soh precisamos da funcao de
    inicializacao que o SWIG gera.
    
    Problema eh, essa inicializacao do modulo precisa ser feita antes do
    Py_Initialize (inicializacao do interpretador do python)... Entao ai sei la
    como resolveriamos isso... Curioso é que a Boost.Python com aquelas macros
    malucas precisava que vc chamasse a funcao initModulo antes do Py_Initialize
    tambem, acho que agora sei porque ahahahahaha
################
Ver com o Wil sobre o método dele pra transformar args VData recebidos numa
implementacao de VData em seu objeto (PyVData)
################
Python, traduzindo GetAttr/GetItem da API para o GetAttr da nossa interface:
    tenta coisas como tipo, checar se objeto eh um dict, se sim usa GetItem,
    senao usa GetAttr.
################
Omar! Parte I das coisas que fiz na interface. Tema de hoje, "Os Wrappers da
Vida".

Como havia dito na reunião, concentrei toda a implementação de função de wrap
na classe VirtualData. Existem cinco versões diferentes, que acho que são
suficientes para a grande maioria dos usos que faremos do sistema de script.

Mas eu mudei o WrapData do LangWrapper. Na verdade, eu semi-nukei ele. Na
verdade da verdade, eu movi ele para o VirtualObject sob o nome de "Create".
Tem umas quatro versões dele, se você ver lá acho que vc vai entender. No
LangWrapper criei um novo método abstrato "NewData" que deve devolver um novo
VData::Ptr criado com o construtor padrão da classe filha. Você precisa
implementar ele!

Se quiser depois podemos discutir essas escolhas, mas eu acho que estou
conseguindo simplificar as coiasas...

Resumindo: implemente os métodos Wrap do VData e o NewData do seu Wrapper.

################
Possível otimização, falar com Omar -> lazyness na hora de ler um atributo.

################
